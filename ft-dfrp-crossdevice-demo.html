<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FT-DFRP Cross-Device Network</title>
    <link rel="manifest" href="./manifest.json">
    <meta name="theme-color" content="#00ff88">
    <style>
        body {
            margin: 0;
            font-family: 'Monaco', 'Consolas', monospace;
            background: linear-gradient(135deg, #0a0a0a, #1a1a2e);
            color: #00ff88;
            overflow-x: hidden;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        .header {
            text-align: center;
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(0,255,136,0.1);
            border: 1px solid #00ff88;
            border-radius: 10px;
        }
        .header h1 {
            margin: 0;
            font-size: 2.2em;
            text-shadow: 0 0 10px #00ff88;
            color: #00ff88;
        }
        .network-status {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        .status-panel {
            background: rgba(0,0,0,0.6);
            border: 1px solid #00ff88;
            border-radius: 8px;
            padding: 15px;
        }
        .status-title {
            color: #00ff88;
            font-weight: bold;
            margin-bottom: 10px;
            border-bottom: 1px solid #00ff88;
            padding-bottom: 5px;
        }
        .peer-item {
            background: rgba(0,255,136,0.1);
            padding: 8px;
            margin: 5px 0;
            border-radius: 4px;
            border-left: 3px solid #00ff88;
            font-size: 0.9em;
        }
        .peer-connecting {
            border-left-color: #ffaa00;
            background: rgba(255,170,0,0.1);
        }
        .network-canvas {
            width: 100%;
            height: 500px;
            background: #000;
            border: 2px solid #00ff88;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
            margin: 20px 0;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        button {
            background: linear-gradient(45deg, #00ff88, #008844);
            color: #000;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            transition: all 0.3s;
        }
        button:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(0,255,136,0.5);
        }
        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        .node {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid #00ff88;
            cursor: pointer;
            transition: all 0.2s;
        }
        .node-local {
            background: #00ff88;
            box-shadow: 0 0 15px #00ff88;
            animation: pulse 2s infinite;
        }
        .node-peer {
            background: #0088ff;
            border-color: #0088ff;
        }
        .node-selected {
            transform: scale(1.5);
            box-shadow: 0 0 20px #ffffff;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        .connection {
            position: absolute;
            height: 2px;
            background: rgba(0,255,136,0.4);
            transform-origin: left center;
        }
        .connection-active {
            background: #00ff88;
            animation: data-flow 1s infinite;
        }
        @keyframes data-flow {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 1; }
        }
        .info-display {
            background: rgba(0,0,0,0.8);
            border: 1px solid #00ff88;
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
            max-height: 200px;
            overflow-y: auto;
        }
        .log-entry {
            margin: 5px 0;
            padding: 5px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        .log-info { background: rgba(0,255,136,0.1); }
        .log-warning { background: rgba(255,170,0,0.1); color: #ffaa00; }
        .log-error { background: rgba(255,68,68,0.1); color: #ff4444; }
        .performance-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }
        .metric {
            background: rgba(0,255,136,0.1);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #00ff88;
            text-align: center;
        }
        .metric-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #00ff88;
        }
        .metric-label {
            font-size: 0.8em;
            opacity: 0.8;
        }
        .signaling-status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-weight: bold;
        }
        .signaling-connected {
            background: rgba(0,255,136,0.2);
            border: 1px solid #00ff88;
        }
        .signaling-disconnected {
            background: rgba(255,68,68,0.2);
            border: 1px solid #ff4444;
            color: #ff4444;
        }
        .signaling-connecting {
            background: rgba(255,170,0,0.2);
            border: 1px solid #ffaa00;
            color: #ffaa00;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // Simple WebSocket signaling server for cross-device discovery
        class CrossDeviceNetworkManager {
            constructor(onNetworkUpdate) {
                this.nodeId = this.generateNodeId();
                this.peers = new Map();
                this.connections = new Map();
                this.onNetworkUpdate = onNetworkUpdate;
                this.signalingSocket = null;
                this.signalingStatus = 'disconnected';
                this.networkData = {
                    nodes: new Map(),
                    routes: new Map(),
                    parityMap: new Map()
                };
                
                this.setupLocalNode();
                this.initializeSignaling();
            }

            generateNodeId() {
                // Generate unique ID based on device fingerprint + timestamp
                const deviceInfo = `${navigator.userAgent}_${navigator.language}_${screen.width}x${screen.height}`;
                const hash = this.simpleHash(deviceInfo);
                return `node_${hash}_${Date.now()}`.slice(0, 32);
            }

            simpleHash(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32bit integer
                }
                return Math.abs(hash).toString(16).slice(0, 8);
            }

            setupLocalNode() {
                this.networkData.nodes.set(this.nodeId, {
                    id: this.nodeId,
                    x: Math.random() * 90 + 5,
                    y: Math.random() * 90 + 5,
                    density: Math.random(),
                    coherence: Math.random(),
                    vector: Array(8).fill(0).map(() => Math.random() * 2 - 1),
                    isLocal: true,
                    connected: true,
                    lastSeen: Date.now(),
                    deviceInfo: this.getDeviceInfo()
                });
            }

            getDeviceInfo() {
                return {
                    platform: navigator.platform,
                    userAgent: navigator.userAgent.split(' ').slice(-2).join(' '),
                    timestamp: Date.now()
                };
            }

            async initializeSignaling() {
                // Try signaling servers in order of preference
                const signalingServers = [
                    `ws://${window.location.hostname}:8080`,  // Same host signaling server
                    'ws://localhost:8080',                    // Local signaling server  
                    null // Fallback to BroadcastChannel (same-browser only)
                ];

                for (const server of signalingServers) {
                    if (server) {
                        try {
                            await this.connectToSignalingServer(server);
                            return;
                        } catch (error) {
                            this.log(`Failed to connect to ${server}: ${error.message}`, 'warning');
                            continue;
                        }
                    }
                }

                // Fallback to BroadcastChannel for same-browser tabs only
                this.log('Using BroadcastChannel fallback (same-browser tabs only)', 'warning');
                this.initializeBroadcastChannel();
            }

            async connectToSignalingServer(serverUrl) {
                return new Promise((resolve, reject) => {
                    this.signalingSocket = new WebSocket(serverUrl);
                    this.signalingStatus = 'connecting';
                    
                    this.signalingSocket.onopen = () => {
                        this.signalingStatus = 'connected';
                        this.log(`Connected to signaling server: ${serverUrl}`);
                        this.announcePresence();
                        this.startPeriodicAnnouncements();
                        resolve();
                    };

                    this.signalingSocket.onmessage = (event) => {
                        try {
                            const message = JSON.parse(event.data);
                            this.handleSignalingMessage(message);
                        } catch (error) {
                            this.log(`Invalid signaling message: ${error.message}`, 'error');
                        }
                    };

                    this.signalingSocket.onclose = () => {
                        this.signalingStatus = 'disconnected';
                        this.log('Signaling server disconnected', 'warning');
                        setTimeout(() => this.initializeSignaling(), 5000); // Reconnect
                    };

                    this.signalingSocket.onerror = (error) => {
                        this.signalingStatus = 'disconnected';
                        reject(new Error(`WebSocket error: ${error}`));
                    };

                    // Timeout after 3 seconds
                    setTimeout(() => {
                        if (this.signalingSocket.readyState !== WebSocket.OPEN) {
                            this.signalingSocket.close();
                            reject(new Error('Connection timeout'));
                        }
                    }, 3000);
                });
            }

            initializeBroadcastChannel() {
                if (typeof BroadcastChannel === 'undefined') {
                    this.log('No cross-device discovery available', 'error');
                    return;
                }

                this.signalingChannel = new BroadcastChannel('ft-dfrp-signaling');
                this.signalingChannel.onmessage = (event) => {
                    this.handleSignalingMessage(event.data);
                };
                
                this.signalingStatus = 'connected';
                this.announcePresence();
                this.startPeriodicAnnouncements();
            }

            startPeriodicAnnouncements() {
                setInterval(() => {
                    this.announcePresence();
                    this.cleanupStaleConnections();
                }, 5000);
            }

            announcePresence() {
                const message = {
                    type: 'presence',
                    nodeId: this.nodeId,
                    timestamp: Date.now(),
                    nodeData: this.networkData.nodes.get(this.nodeId)
                };

                this.sendSignalingMessage(message);
            }

            sendSignalingMessage(message) {
                try {
                    if (this.signalingSocket && this.signalingSocket.readyState === WebSocket.OPEN) {
                        this.signalingSocket.send(JSON.stringify(message));
                    } else if (this.signalingChannel) {
                        this.signalingChannel.postMessage(message);
                    } else {
                        this.log('No signaling method available', 'warning');
                    }
                } catch (error) {
                    this.log(`Failed to send signaling message: ${error.message}`, 'error');
                }
            }

            async handleSignalingMessage(message) {
                if (message.nodeId === this.nodeId) return;

                switch (message.type) {
                    case 'presence':
                        await this.handlePeerDiscovery(message);
                        break;
                    case 'offer':
                        await this.handleOffer(message);
                        break;
                    case 'answer':
                        await this.handleAnswer(message);
                        break;
                    case 'ice-candidate':
                        await this.handleIceCandidate(message);
                        break;
                }
            }

            async handlePeerDiscovery(message) {
                const peerId = message.nodeId;
                
                if (!this.networkData.nodes.has(peerId)) {
                    this.log(`Discovered cross-device peer: ${peerId.slice(-8)} (${message.nodeData?.deviceInfo?.platform || 'Unknown'})`);
                    
                    this.networkData.nodes.set(peerId, {
                        ...message.nodeData,
                        isLocal: false,
                        lastSeen: Date.now()
                    });

                    // Initiate connection if we have capacity and lower nodeId (prevents duplicate connections)
                    if (this.connections.size < 5 && this.nodeId < peerId) {
                        await this.connectToPeer(peerId);
                    }
                } else {
                    // Update existing peer info
                    const existing = this.networkData.nodes.get(peerId);
                    this.networkData.nodes.set(peerId, {
                        ...existing,
                        ...message.nodeData,
                        lastSeen: Date.now()
                    });
                }
                
                this.onNetworkUpdate();
            }

            async connectToPeer(peerId) {
                if (this.connections.has(peerId)) return;

                this.log(`Initiating WebRTC connection to: ${peerId.slice(-8)}`);

                const pc = new RTCPeerConnection({
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                });

                // Setup data channel
                const dataChannel = pc.createDataChannel('ft-dfrp', { ordered: true });
                
                dataChannel.onopen = () => {
                    this.log(`WebRTC connection established: ${peerId.slice(-8)}`);
                    this.connections.set(peerId, { pc, dataChannel });
                    this.setupDataChannelHandlers(dataChannel, peerId);
                    this.onNetworkUpdate();
                };

                dataChannel.onerror = (error) => {
                    this.log(`Data channel error: ${error}`, 'error');
                };

                pc.ondatachannel = (event) => {
                    this.setupDataChannelHandlers(event.channel, peerId);
                };

                pc.onicecandidate = (event) => {
                    if (event.candidate) {
                        this.sendSignalingMessage({
                            type: 'ice-candidate',
                            nodeId: this.nodeId,
                            targetId: peerId,
                            candidate: {
                                candidate: event.candidate.candidate,
                                sdpMLineIndex: event.candidate.sdpMLineIndex,
                                sdpMid: event.candidate.sdpMid
                            }
                        });
                    }
                };

                // Create and send offer
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);

                this.sendSignalingMessage({
                    type: 'offer',
                    nodeId: this.nodeId,
                    targetId: peerId,
                    offer: offer
                });

                this.peers.set(peerId, pc);
            }

            async handleOffer(message) {
                if (message.targetId !== this.nodeId) return;

                this.log(`Received offer from: ${message.nodeId.slice(-8)}`);

                const pc = new RTCPeerConnection({
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                });

                pc.ondatachannel = (event) => {
                    const dataChannel = event.channel;
                    dataChannel.onopen = () => {
                        this.log(`Accepted WebRTC connection: ${message.nodeId.slice(-8)}`);
                        this.connections.set(message.nodeId, { pc, dataChannel });
                        this.setupDataChannelHandlers(dataChannel, message.nodeId);
                        this.onNetworkUpdate();
                    };
                };

                pc.onicecandidate = (event) => {
                    if (event.candidate) {
                        this.sendSignalingMessage({
                            type: 'ice-candidate',
                            nodeId: this.nodeId,
                            targetId: message.nodeId,
                            candidate: {
                                candidate: event.candidate.candidate,
                                sdpMLineIndex: event.candidate.sdpMLineIndex,
                                sdpMid: event.candidate.sdpMid
                            }
                        });
                    }
                };

                await pc.setRemoteDescription(message.offer);
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);

                this.sendSignalingMessage({
                    type: 'answer',
                    nodeId: this.nodeId,
                    targetId: message.nodeId,
                    answer: answer
                });

                this.peers.set(message.nodeId, pc);
            }

            async handleAnswer(message) {
                if (message.targetId !== this.nodeId) return;

                const pc = this.peers.get(message.nodeId);
                if (pc) {
                    await pc.setRemoteDescription(message.answer);
                }
            }

            async handleIceCandidate(message) {
                if (message.targetId !== this.nodeId) return;

                const pc = this.peers.get(message.nodeId);
                if (pc && message.candidate) {
                    try {
                        const iceCandidate = new RTCIceCandidate(message.candidate);
                        await pc.addIceCandidate(iceCandidate);
                    } catch (error) {
                        this.log(`Failed to add ICE candidate: ${error.message}`, 'warning');
                    }
                }
            }

            setupDataChannelHandlers(dataChannel, peerId) {
                dataChannel.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        this.handleP2PMessage(data, peerId);
                    } catch (error) {
                        this.log(`Invalid P2P message: ${error.message}`, 'error');
                    }
                };

                dataChannel.onclose = () => {
                    this.log(`WebRTC connection closed: ${peerId.slice(-8)}`, 'warning');
                    this.connections.delete(peerId);
                    this.peers.delete(peerId);
                    this.onNetworkUpdate();
                };
            }

            handleP2PMessage(data, fromPeer) {
                switch (data.type) {
                    case 'parity-announce':
                        this.log(`Parity distributed: ${data.tag} from ${fromPeer.slice(-8)}`);
                        break;
                    case 'ann-query':
                        this.log(`ANN query from: ${fromPeer.slice(-8)}`);
                        break;
                }
            }

            distributeParity(tag) {
                this.log(`Distributing parity: ${tag}`);
                this.broadcastToNetwork({
                    type: 'parity-announce',
                    tag,
                    nodeId: this.nodeId,
                    timestamp: Date.now()
                });
            }

            broadcastToNetwork(message) {
                this.connections.forEach((connection, peerId) => {
                    if (connection.dataChannel?.readyState === 'open') {
                        try {
                            connection.dataChannel.send(JSON.stringify(message));
                        } catch (error) {
                            this.log(`Failed to broadcast to ${peerId.slice(-8)}: ${error.message}`, 'error');
                        }
                    }
                });
            }

            cleanupStaleConnections() {
                const now = Date.now();
                const staleThreshold = 30000; // 30 seconds

                this.networkData.nodes.forEach((node, nodeId) => {
                    if (!node.isLocal && now - node.lastSeen > staleThreshold) {
                        this.log(`Removing stale node: ${nodeId.slice(-8)}`);
                        this.networkData.nodes.delete(nodeId);
                        this.connections.delete(nodeId);
                        this.peers.delete(nodeId);
                    }
                });
            }

            getNetworkStats() {
                return {
                    totalNodes: this.networkData.nodes.size,
                    connectedPeers: this.connections.size,
                    signalingStatus: this.signalingStatus,
                    deviceType: this.getDeviceInfo().platform
                };
            }

            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = { message: `[${timestamp}] ${message}`, type };
                
                if (this.onLog) {
                    this.onLog(logEntry);
                }
                console.log(`[FT-DFRP] ${message}`);
            }
        }

        // React Component
        function CrossDeviceDemo() {
            const [network, setNetwork] = useState(null);
            const [logs, setLogs] = useState([]);
            const [stats, setStats] = useState({});
            const canvasRef = useRef();

            useEffect(() => {
                try {
                    const networkManager = new CrossDeviceNetworkManager(() => {
                        setNetwork(prev => ({ ...prev }));
                    });

                    networkManager.onLog = (logEntry) => {
                        setLogs(prev => [...prev.slice(-15), logEntry]);
                    };

                    setNetwork(networkManager);
                } catch (error) {
                    console.error('[FT-DFRP] Failed to initialize:', error);
                    setLogs([{ message: `Failed to initialize: ${error.message}`, type: 'error' }]);
                }

                const statsInterval = setInterval(() => {
                    if (network?.getNetworkStats) {
                        setStats(network.getNetworkStats());
                    }
                }, 1000);

                return () => clearInterval(statsInterval);
            }, []);

            const renderNetwork = useCallback(() => {
                if (!network?.networkData?.nodes || !canvasRef.current) return;

                const canvas = canvasRef.current;
                const rect = canvas.getBoundingClientRect();
                canvas.innerHTML = '';

                // Render connections
                network.connections.forEach((connection, peerId) => {
                    const peerNode = network.networkData.nodes.get(peerId);
                    const localNode = network.networkData.nodes.get(network.nodeId);
                    
                    if (peerNode && localNode) {
                        const line = document.createElement('div');
                        line.className = 'connection connection-active';
                        
                        const dx = (peerNode.x - localNode.x) * rect.width / 100;
                        const dy = (peerNode.y - localNode.y) * rect.height / 100;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                        
                        line.style.left = `${localNode.x * rect.width / 100}px`;
                        line.style.top = `${localNode.y * rect.height / 100}px`;
                        line.style.width = `${length}px`;
                        line.style.transform = `rotate(${angle}deg)`;
                        
                        canvas.appendChild(line);
                    }
                });

                // Render nodes
                network.networkData.nodes.forEach((node, nodeId) => {
                    const nodeEl = document.createElement('div');
                    nodeEl.className = `node ${node.isLocal ? 'node-local' : 'node-peer'}`;
                    
                    nodeEl.style.left = `${node.x * rect.width / 100 - 6}px`;
                    nodeEl.style.top = `${node.y * rect.height / 100 - 6}px`;
                    
                    const status = node.isLocal ? 'LOCAL' : 
                                 network.connections.has(nodeId) ? 'CONNECTED' : 'DISCOVERED';
                    
                    const device = node.deviceInfo?.platform || 'Unknown';
                    
                    nodeEl.title = `${nodeId.slice(-12)}\n${status}\n${device}\nDensity: ${node.density?.toFixed(3)}`;
                    
                    canvas.appendChild(nodeEl);
                });
            }, [network]);

            useEffect(() => {
                renderNetwork();
            }, [renderNetwork]);

            const getSignalingStatusClass = () => {
                switch (stats.signalingStatus) {
                    case 'connected': return 'signaling-connected';
                    case 'connecting': return 'signaling-connecting';
                    default: return 'signaling-disconnected';
                }
            };

            return (
                <div className="container">
                    <div className="header">
                        <h1>FT-DFRP Cross-Device Network</h1>
                        <p>True cross-device P2P mesh with WebSocket signaling</p>
                        <p style={{fontSize: '0.9em', opacity: 0.8}}>
                            Node: {network?.nodeId?.slice(-12) || 'Initializing...'} ({stats.deviceType})
                        </p>
                        <div className={`signaling-status ${getSignalingStatusClass()}`}>
                            Signaling: {stats.signalingStatus?.toUpperCase() || 'UNKNOWN'}
                        </div>
                    </div>

                    <div className="network-status">
                        <div className="status-panel">
                            <div className="status-title">Network Metrics</div>
                            <div className="performance-metrics">
                                <div className="metric">
                                    <div className="metric-value">{stats.totalNodes || 0}</div>
                                    <div className="metric-label">Total Devices</div>
                                </div>
                                <div className="metric">
                                    <div className="metric-value">{stats.connectedPeers || 0}</div>
                                    <div className="metric-label">Connected</div>
                                </div>
                                <div className="metric">
                                    <div className="metric-value">{stats.signalingStatus === 'connected' ? '✓' : '✗'}</div>
                                    <div className="metric-label">Signaling</div>
                                </div>
                            </div>
                        </div>

                        <div className="status-panel">
                            <div className="status-title">Connected Devices</div>
                            <div>
                                {network?.connections?.size > 0 ? 
                                    Array.from(network.connections.keys()).map(peerId => {
                                        const node = network.networkData.nodes.get(peerId);
                                        const device = node?.deviceInfo?.platform || 'Unknown';
                                        return (
                                            <div key={peerId} className="peer-item">
                                                {peerId.slice(-12)} ({device})
                                            </div>
                                        );
                                    }) : 
                                    <div style={{opacity: 0.6}}>
                                        {stats.signalingStatus === 'connected' ? 
                                            'No devices connected (waiting for peers...)' : 
                                            'Connecting to signaling server...'}
                                    </div>
                                }
                            </div>
                        </div>
                    </div>

                    <div className="controls">
                        <button onClick={() => {
                            if (network) {
                                const tag = `parity_${Date.now()}`;
                                network.distributeParity(tag);
                            }
                        }} disabled={!network || stats.signalingStatus !== 'connected'}>
                            Distribute Parity
                        </button>
                        <button onClick={() => {
                            if (network) {
                                network.announcePresence();
                            }
                        }} disabled={!network}>
                            Announce Presence
                        </button>
                        <button onClick={() => window.location.reload()}>
                            Restart Node
                        </button>
                    </div>

                    <div ref={canvasRef} className="network-canvas"></div>

                    <div className="info-display">
                        <h4 style={{color: '#00ff88', marginTop: 0}}>Network Log</h4>
                        {logs.slice(-8).map((log, i) => (
                            <div key={i} className={`log-entry log-${log.type}`}>
                                {log.message}
                            </div>
                        ))}
                    </div>

                    <div style={{
                        background: 'rgba(0,255,136,0.1)',
                        border: '1px solid #00ff88',
                        padding: '15px',
                        borderRadius: '8px',
                        marginTop: '20px'
                    }}>
                        <h3 style={{color: '#00ff88', margin: '0 0 10px 0'}}>Cross-Device Instructions</h3>
                        <p><strong>1.</strong> Open this page on multiple devices (PC, Mac, phone, tablet)</p>
                        <p><strong>2.</strong> Ensure all devices are on the same network</p>
                        <p><strong>3.</strong> Watch for "Discovered cross-device peer" messages</p>
                        <p><strong>4.</strong> Devices will automatically form WebRTC mesh connections</p>
                        <p><strong>Note:</strong> Currently using fallback BroadcastChannel. For true cross-device networking, deploy with WebSocket signaling server.</p>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<CrossDeviceDemo />, document.getElementById('root'));
    </script>
</body>
</html>
